use cardano_serialization_lib::chain_crypto::{Ed25519, Verification, VerificationAlgorithm};
use ciborium::cbor;

use ciborium::value::Value as Cbor;

use crate::data::NetworkId;
use crate::data::PublicKeyHex;
use crate::data::RewardsAddress;
use crate::data::{Registration, SignedRegistration, StakeKeyHex, VotingPurpose};
use crate::error::RegistrationError;
use crate::{DataProvider, Signature, SignatureHex, VotingPowerSource};
use validity::Validate;

#[cfg(test)]
mod tests;

#[derive(Clone, Copy)]
pub struct ValidationCtx<'a> {
    pub db: &'a dyn DataProvider,
    /// Used for validating addresses
    pub network_id: NetworkId,
    pub expected_voting_purpose: VotingPurpose,
}

impl Validate for SignedRegistration {
    type Context<'a> = ValidationCtx<'a>;
    type Error = RegistrationError;

    fn is_valid(&self, ctx: Self::Context<'_>) -> Result<(), Self::Error> {
        let SignedRegistration {
            registration,
            signature,
            tx_id: _,
        } = self;

        // validate_voting_power(&registration.voting_power_source)?;
        // validate_stake_key(&registration.stake_key, ctx)?;
        // validate_rewards_address(&registration.rewards_address)?;
        // validate_voting_purpose(registration.voting_purpose, ctx)?;
        validate_signature(&registration, &signature)?;

        Ok(())
    }
}

/// Delegated voting power must have at least one delegation
fn validate_voting_power(source: &VotingPowerSource) -> Result<(), RegistrationError> {
    match source {
        VotingPowerSource::Delegated(vec) if vec.len() == 0 => {
            Err(RegistrationError::EmptyDelegations)
        }
        _ => Ok(()),
    }
}

/// A stake key must be a type 14 or 15 shelley address, and must match the desired network id
fn validate_stake_key(
    stake_address: &StakeKeyHex,
    ctx: ValidationCtx,
) -> Result<(), RegistrationError> {
    match stake_address.ty() {
        14 | 15 => {}
        i => return Err(RegistrationError::StakeKeyWrongType(i)),
    }

    let network_id = stake_address.network_id();
    if Some(ctx.network_id) != stake_address.network_id() {
        return Err(RegistrationError::StakeKeyWrongNetwork {
            expected: ctx.network_id,
            actual: network_id,
        });
    }

    Ok(())
}

/// We don't perform validation (other than type safety) on rewards addresses due to historical
/// registrations using MIR transfer addresses
fn validate_rewards_address(_: &RewardsAddress) -> Result<(), RegistrationError> {
    Ok(())
}

/// The voting purpose must simply match the voting purpose passed to the function
///
/// In practice, this shouldn't usually occur, since queries should filter based on voting purpose.
/// However, we leave this check in so that buggy queries don't lead to incorrect snapshots
fn validate_voting_purpose(
    purpose: VotingPurpose,
    ctx: ValidationCtx,
) -> Result<(), RegistrationError> {
    if purpose != ctx.expected_voting_purpose {
        return Err(RegistrationError::IncorrectVotingPurpose {
            expected: ctx.expected_voting_purpose,
            actual: purpose,
        });
    }

    Ok(())
}

/// The signature is generated by:
///  - CBOR encoding the registration
///  - blake2b-256 hashing those bytes
///  - signing the hash with the private key used to generate the stake key
fn validate_signature(
    registration: &Registration,
    Signature { inner }: &Signature,
) -> Result<(), RegistrationError> {
    let cbor = registration_to_cbor(registration);
    let bytes = cbor_to_bytes(cbor);
    println!("cbor hex = {}", hex::encode(&bytes));
    let hash_bytes = blake2b_256(&bytes);
    println!("hash hex = {}", hex::encode(&hash_bytes));

    match Ed25519::verify_bytes(&registration.stake_key.0 .0, &inner.0, &hash_bytes) {
        Verification::Success => Ok(()),
        Verification::Failed => Err(RegistrationError::MismatchedSignature { hash_bytes }),
    }
}

const HASH_SIZE: usize = 32;

/// Simple helper function to compute the blake2b_256 hash of a byte slice
fn blake2b_256(bytes: &[u8]) -> [u8; HASH_SIZE] {
    use blake2::digest::{Update, VariableOutput};

    let mut hasher = blake2::Blake2s256::new(HASH_SIZE).unwrap();
    hasher.update(bytes);
    let mut buf = [0u8; HASH_SIZE];
    hasher.finalize_variable(&mut buf).unwrap();
    buf
}

fn registration_to_cbor(
    Registration {
        voting_power_source,
        stake_key,
        rewards_address: rewards_addr,
        nonce,
        voting_purpose: _,
    }: &Registration,
) -> Cbor {
    // we do this manually because it's not really a 1:1 conversion and serde can't handle integer
    // keys

    cbor!({
        61284 => {
            1 => voting_power_source,
            2 => stake_key,
            3 => rewards_addr,
            4 => nonce,
        }
    })
    .unwrap()
}

fn cbor_to_bytes(cbor: Cbor) -> Vec<u8> {
    let mut bytes: Vec<u8> = vec![];
    ciborium::ser::into_writer(&cbor, &mut bytes).unwrap();
    bytes
}
