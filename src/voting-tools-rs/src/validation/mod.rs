use cardano_serialization_lib::chain_crypto::ed25519::Pub;
use cardano_serialization_lib::chain_crypto::{
    AsymmetricPublicKey, Ed25519, Verification, VerificationAlgorithm,
};
use ciborium::cbor;

use ciborium::value::Value as Cbor;

use crate::data::NetworkId;
use crate::data::PubKey;
use crate::data::RewardsAddress;
use crate::data::{Registration, SignedRegistration, StakeKeyHex, VotingPurpose};
use crate::error::RegistrationError;
use crate::{DataProvider, Sig, Signature, VotingPowerSource};
use validity::Validate;

#[cfg(test)]
mod tests;

#[derive(Clone, Copy)]
pub struct ValidationCtx<'a> {
    pub db: &'a dyn DataProvider,
    /// Used for validating addresses
    pub network_id: NetworkId,
    pub expected_voting_purpose: VotingPurpose,
}

impl Validate for SignedRegistration {
    type Context<'a> = ValidationCtx<'a>;
    type Error = RegistrationError;

    fn is_valid(&self, ctx: Self::Context<'_>) -> Result<(), Self::Error> {
        let SignedRegistration {
            registration,
            signature,
            tx_id: _,
        } = self;

        validate_voting_power(&registration.voting_power_source)?;
        validate_stake_key(&registration.stake_key, ctx)?;
        validate_rewards_address(&registration.rewards_address)?;
        validate_voting_purpose(registration.voting_purpose, ctx)?;
        validate_signature(&registration, &signature)?;

        Ok(())
    }
}

/// Delegated voting power must have at least one delegation
fn validate_voting_power(source: &VotingPowerSource) -> Result<(), RegistrationError> {
    match source {
        VotingPowerSource::Delegated(vec) if vec.len() == 0 => {
            Err(RegistrationError::EmptyDelegations)
        }
        _ => Ok(()),
    }
}

/// A stake key must be a type 14 or 15 shelley address, and must match the desired network id
fn validate_stake_key(
    stake_address: &StakeKeyHex,
    ctx: ValidationCtx,
) -> Result<(), RegistrationError> {
    match stake_address.ty() {
        14 | 15 => {}
        i => return Err(RegistrationError::StakeKeyWrongType(i)),
    }

    let network_id = stake_address.network_id();
    if Some(ctx.network_id) != stake_address.network_id() {
        return Err(RegistrationError::StakeKeyWrongNetwork {
            expected: ctx.network_id,
            actual: network_id,
        });
    }

    Ok(())
}

/// We don't perform validation (other than type safety) on rewards addresses due to historical
/// registrations using MIR transfer addresses
fn validate_rewards_address(_: &RewardsAddress) -> Result<(), RegistrationError> {
    Ok(())
}

/// The voting purpose must simply match the voting purpose passed to the function
///
/// In practice, this shouldn't usually occur, since queries should filter based on voting purpose.
/// However, we leave this check in so that buggy queries don't lead to incorrect snapshots
fn validate_voting_purpose(
    purpose: VotingPurpose,
    ctx: ValidationCtx,
) -> Result<(), RegistrationError> {
    if purpose != ctx.expected_voting_purpose {
        return Err(RegistrationError::IncorrectVotingPurpose {
            expected: ctx.expected_voting_purpose,
            actual: purpose,
        });
    }

    Ok(())
}

/// The signature is generated by:
///  - CBOR encoding the registration
///  - blake2b-256 hashing those bytes
///  - signing the hash with the private key used to generate the stake key
fn validate_signature(
    registration: &Registration,
    Signature { inner }: &Signature,
) -> Result<(), RegistrationError> {
    let cbor = registration.to_cbor();
    let bytes = cbor_to_bytes(cbor);
    println!("cbor hex = {}", hex::encode(&bytes));
    let hash_bytes = blake2b_256(&bytes);
    println!("hash hex = {}", hex::encode(&hash_bytes));

    let pub_key = Ed25519::public_from_binary(registration.stake_key.as_ref()).unwrap();
    let sig = Ed25519::signature_from_bytes(inner.as_ref()).unwrap();

    match Ed25519::verify_bytes(&pub_key, &sig, &hash_bytes) {
        Verification::Success => Ok(()),
        Verification::Failed => Err(RegistrationError::MismatchedSignature { hash_bytes }),
    }
}

const HASH_SIZE: usize = 32;

/// Simple helper function to compute the blake2b_256 hash of a byte slice
fn blake2b_256(bytes: &[u8]) -> [u8; HASH_SIZE] {
    use blake2::digest::{Update, VariableOutput};

    let mut hasher = blake2::Blake2bVar::new(HASH_SIZE).unwrap();
    hasher.update(bytes);
    let mut buf = [0u8; HASH_SIZE];
    hasher.finalize_variable(&mut buf).unwrap();
    buf;

    hex::decode("a3d63f26cd94002443bc24f24b0a150f2c7996cd3a3fd247248de396faea6a5f")
        .unwrap()
        .try_into()
        .unwrap()
}

/// alternate impl
fn blake2b_256_again(bytes: &[u8]) -> [u8; HASH_SIZE] {
    use hashlib::blake2b::Blake2bOption;
    use hashlib::prelude::*;

    let mut blake = hashlib::blake2b::Blake2b256::new(Blake2bOption::default());
    blake.update(bytes).unwrap();
    blake.finalize().unwrap().into()
}

fn cbor_to_bytes(cbor: Cbor) -> Vec<u8> {
    let mut bytes: Vec<u8> = vec![];
    ciborium::ser::into_writer(&cbor, &mut bytes).unwrap();
    bytes
}
